5 17
2

{
    1. 5 10 9 18 17 // 2초
    2. 5 4 8 16 17 // 2초
    3. ... // 더 있을지도 모름
}
-> 큐의 삽입 배치 순서는 상관이 없을 것 같다

오답 케이스 분석
4 6

(4,0) -> (8,0) (5,1) (3,1)
(8,0) -> (5,1) (3,1) (16,0) (9,1) (7,1)
(5,1) -> (3,1)//이게 최단 거리지만 (16,0) (9,1) (7,1) (10,1) (6,2)//여기서 먼저 뽑힌다 (4,2)

-> 큐의 삽입 배치 순서는 상관이 있었다 (내 코드에서만): 따라서 같은 시간대의 큐를 탐색시키려고 함
(3,1) -> (16,0) (9,1) (7,1) (10,1) (6,2) (4,2) (6,1) (4,1) (2,1)

메모리 초과로 틀렸다.

4 6

(4,0) -> (8,0) (5,1) (3,1)
(8,0) -> (5,1) (3,1) (7,1)
(5,1) -> (3,1) (7,1) (10,1) (6,2) (4,2)
(3,1) -> (7,1) (10,1) (6,2) (4,2) (6,1) (4,1) (2,1)
(7,1) -> (10,1) (6,2) (4,2) (6,1) (4,1) (2,1) (6,2)

